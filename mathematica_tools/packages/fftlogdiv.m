(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)


BeginPackage["fftlogdiv`"]
UVIRbiases::usage="Gives range for convergent IR and UV limit";

Pk::usage="To be replaced by P(k0) when adding divergence";
Pq::usage="To be replaced by integral over q0 of P(q0) when adding divergence";
Begin["`Private`"]

Get[NotebookDirectory[]<>"globalvars.m"] ;

UVdiv[fct0_]:= Module[{fct=fct0},
expr=q0^2 fct//.{k0-> \[Epsilon] q0}//Simplify//Rationalize;

expr = FullSimplify[Normal[Series[expr ,{\[Epsilon],0,4}]]];

expr = FullSimplify[Integrate[ expr,{phi,0,2\[Pi]}]];

expr = ExpandAll[Integrate[expr,{muq,-1,1}]];

expr  =FullSimplify[Collect[Integrate[expr,q0]//.{\[Epsilon]-> k0/q0},q0]]
]
IRdiv[fct0_]:= Module[{fct=fct0},
expr=q0^2 fct//.{q0-> \[Epsilon] k0}//Simplify//Rationalize;

expr = FullSimplify[Normal[Series[expr ,{\[Epsilon],0,1}]]];

expr = FullSimplify[Integrate[ expr,{phi,0,2\[Pi]}]];

expr = ExpandAll[Integrate[expr,{muq,-1,1}]];

expr  =FullSimplify[Collect[Integrate[expr,q0]//.{\[Epsilon]-> q0/k0},q0]]
]
UVP[fct0_]:= Module[{fct=fct0},
expr=q0^2 fct//.{k0-> \[Epsilon] q0}//Simplify//Rationalize;

expr = 1/(2\[Pi])^3 FullSimplify[Normal[Series[expr ,{\[Epsilon],0,4}]]];

expr = FullSimplify[Integrate[ expr,{phi,0,2\[Pi]}]];

expr = ExpandAll[Integrate[expr,{muq,-1,1}]]//.{\[Epsilon]-> k0/q0};
Rationalize[expr]
]
IRP[fct0_]:= Module[{fct=fct0},
expr=q0^2 fct//.{q0-> \[Epsilon] k0}//Simplify//Rationalize;

expr = 1/(2\[Pi])^3FullSimplify[Normal[Series[expr ,{\[Epsilon],0,1}]]];

expr = FullSimplify[Integrate[ expr,{phi,0,2\[Pi]}]];

expr = 2(6\[Pi]^2) ExpandAll[Integrate[expr,{muq,-1,1}]]//.{\[Epsilon]-> q0/k0};
Rationalize[expr]
]
End[] (*End Private Context*)

q0factor[v0_]:=Module[{v=v0},
v=Expand[v];
v=If[Head[v]===Plus,List@@v,{v}];

Tv=Table[{Simplify[ q0 D[v[[l]],q0]/v[[l]]],v[[l]]/. {q0->1}},{l,1,Length[v]}];
Coefs={};
Tuniq={};
For[i=1,i<Length[Tv]+1,i++,
If[!MemberQ[Coefs,Tv[[i,1]]],AppendTo[Coefs,Tv[[i,1]]];AppendTo[Tuniq,Tv[[i]]],coefind=Position[Coefs,Tv[[i,1]]][[1]];
Tuniq[[coefind,2]]+=Tv[[i,2]];]
];
Simplify[Tuniq]
]

singlebias[expr0_]:=Module[{expr=expr0},
default=\[Nu]\[Element]Reals;
{q0pow,coef}=expr[[{1,2}]];

s=Assuming[$Assumptions,FullSimplify@Solve[q0^q0pow==0,{q0,\[Nu]}]][[1]][[1]];
reg=If[ResourceFunction["EmptyQ"][s],default,If[s[[1]]==q0&&s[[2]][[1]]==0,Not[s[[2]][[2]]],default]];
Print[reg,s];
reg

]


UVIRbiases[expr0_,mode0_]:=Module[{expr=expr0,mode=mode0},
Pl1=q0^\[Nu];
pIR=Pq Pk;
If[mode=="sym",
Pl2= Norm[k-q]^\[Nu];
pUV=Pq^2,
Pl2= k0^\[Nu];
pUV=Pq Pk];
Print[Pl1 ,Pl2,pIR,pUV];
UVq0fact=q0factor[UVdiv[expr Pl1 Pl2]];
IRq0fact=q0factor[IRdiv[expr  Pl1 Pl2]];
IRq0fact=Array[{-IRq0fact[[#]][[1]],IRq0fact[[#]][[2]]}&,Length[UVq0fact]];

corrections={pIR IRP[expr],pUV UVP[expr]};

q0fact={IRq0fact,UVq0fact};
regions={};
For[d=1,d<3,d++,
regionconstraints=Array[singlebias[q0fact[[d]][[#]]]&,Length[q0fact[[d]]]];
AppendTo[regionconstraints,\[Nu]\[Element]Reals];
region=ImplicitRegion[regionconstraints,{\[Nu]}];
region=Reduce[Element[{\[Nu]},region],\[Nu]];
AppendTo[regions,{region,corrections[[d]]}];
];

regions
]
EndPackage[]



