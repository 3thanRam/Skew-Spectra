(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)


BeginPackage["fftlogdiv`"]
UVIRbiases::usage="Gives range for convergent IR and UV limit";

Pk::usage="To be replaced by P(k0) when adding divergence";
Pq::usage="To be replaced by integral over q0 of P(q0) (and any q0 dependent terms) when adding divergence";
Begin["`Private`"]

Get[NotebookDirectory[]<>"globalvars.m"] ;

(*mathematica can often calculate an integral faster by first calculating the indefinite integration then taking the limit for the different bounds*)
fastintegral[expr0_,var0_,a0_,b0_]:=Module[{expr=expr0,var=var0,a=a0,b=b0},
indef=Integrate[expr,var];
Ib=Quiet[Limit[indef,var->b,Direction->"FromBelow"]];
Ia=Quiet[Limit[indef,var->a,Direction->"FromAbove"]];
Ib-Ia
];


(*calculate the integration over muq and phi of the leading piece of an expression in UV and IR limit*)
Clear[phimuintegratelimit]
phimuintegratelimit[fct0_,limit0_]:=phimuintegratelimit[fct0,limit0]=Module[{fct=fct0,limit=limit0},
q0k0replace=If[limit=="UV",{k0-> \[Epsilon] q0},{q0-> \[Epsilon] k0}];
ordeps=If[limit=="UV",4,1];

expr=q0^2 fct/.q0k0replace//Rationalize//Simplify;
expr =Normal[Series[expr ,{\[Epsilon],0,ordeps}]]//Simplify;
expr =Assuming[ $Assumptions,fastintegral[expr,phi,0,2\[Pi]]]// Simplify;
expr =fastintegral[expr,muq,-1,1] //ExpandAll
];



(*get behaviour of UV/IR limit in terms of \[Nu] in order to get a condition of divergence for \[Nu]*)
Clear[integrandlimit]
integrandlimit[fct0_,limit0_]:=integrandlimit[fct0,limit0]=Module[{fct=fct0,limit=limit0},
epsreplace=If[limit=="UV",{\[Epsilon]-> k0/q0},{\[Epsilon]-> q0/k0}];
Collect[Integrate[fct0,q0]/.epsreplace,q0] //Simplify
];

(*get behaviour of UV/IR limit in order to get account for divergence of fftlog calculation *)
Clear[Plimit]
Plimit[fct0_,limit0_]:=Plimit[fct0,limit0]= Module[{fct=fct0,limit=limit0},
epsreplace=If[limit=="UV",{\[Epsilon]-> k0/q0},{\[Epsilon]-> q0/k0}];
1/(2\[Pi])^3 fct0/.epsreplace //Rationalize 
];

(*split expression into powers of q0*)
q0factor[v0_]:=Module[{v=v0},
v=Expand[v];
v=If[Head[v]===Plus,List@@v,{v}];
v=DeleteCases[v,0];
Tv=Table[{Simplify[ q0 D[v[[l]],q0]/v[[l]]],v[[l]]/. {q0->1}},{l,1,Length[v]}];
grouped=GroupBy[Tv,#[[1]]&->(#[[2]]&)];
groupedSums=KeyValueMap[#1->Total[#2]&,grouped];
Tuniq=Flatten/@List@@@Normal@groupedSums;
Simplify[Tuniq]
];

(*get range of \[Nu] values where an expression could diverge*)
singlebias[expr0_]:=Module[{expr=expr0},
default=\[Nu]\[Element]Reals;
{q0pow,coef}=expr[[{1,2}]];
s=Quiet[Assuming[$Assumptions,Simplify@Solve[q0^q0pow==0,{q0,\[Nu]}]][[1]][[1]]];
reg=If[ResourceFunction["EmptyQ"][s],default,If[s[[1]]==q0&&s[[2]][[1]]==0,Not[s[[2]][[2]]],default]]

];

(*simplifies region with multiple possibly redundant constraints*) 
reducedregion[regionconstraints0_]:=
Assuming[$Assumptions, Reduce[Element[{\[Nu]},ImplicitRegion[Join[regionconstraints0,{\[Nu]\[Element]Reals}],{\[Nu]}]],\[Nu]]];

extractnuterms:=DeleteCases[vi_/;FreeQ[vi,\[Nu]]==True];

(*get power of k0/q0 of an expression *)
vectpow[vect0_,expr0_]:=Module[{vect=vect0,expr=expr0},
normexpr=If[expr==0,1,expr];
expr=vect D[expr,vect]/normexpr ;
expr=If[Head[expr]===Plus,List@@expr,{expr}];
res=extractnuterms[expr];
If[Length[res]==0,0,res[[1]]/\[Nu]]
];

(*replace k0^nu (and q0^nu) by Pk (and Pq)*)
replacePqPk[expr0_]:=Module[{expr=expr0},
powPk=vectpow[k0,expr];
powPq=vectpow[q0,expr];
expr0 (Pk/k0^\[Nu])^powPk  (Pq/q0^\[Nu])^powPq  //Simplify
];

(*get leading UV and IR divergent pieces and the ranges where its necessary to account for them *)
UVIRbiases[expr0_,mode0_]:=Module[{expr=expr0,mode=mode0},
Pl1=q0^\[Nu];
Pl2=If[mode=="sym", Norm[k-q]^\[Nu],k0^\[Nu]];

{IRint,UVint}=Table[phimuintegratelimit[expr  Pl1 Pl2,limit],{limit,{"IR","UV"}}];
IRq0fact=q0factor[integrandlimit[IRint,"IR"]];
UVq0fact=q0factor[integrandlimit[UVint,"UV"]];

IRq0fact=Array[{-IRq0fact[[#]][[1]],IRq0fact[[#]][[2]]}&,Length[IRq0fact]];
q0fact={IRq0fact,UVq0fact};

corrections={replacePqPk[ Plimit[IRint,"IR"]],replacePqPk[ Plimit[UVint,"UV"]]};


regionfct[d_]:=Block[{regionconstraints},
regionconstraints=Array[singlebias[q0fact[[d]][[#]]]&,Length[q0fact[[d]]]];
(*{divergence range, divergent piece}*)
{reducedregion[regionconstraints],corrections[[d]]}
];

(*IR,UV divergence information*)
{regionfct[1],regionfct[2]}
]
End[] 
EndPackage[]



